v_real <- function(v_codif,vmin,vmax) {
valor <- (v_codif+1)*(vmax-vmin)/2+vmin
return(valor)
}
vmax = 200
vmin = 400
mydata2$x2 <- mapply(  function(x) {(x+1)*(vmax-vmin)/2+vmin} , mydata$x2)
vmax = 100
vmin = 200
mydata2$x1 <- mapply(  function(x) {(x+1)*(vmax-vmin)/2+vmin} , mydata$x1)
mydata2
fit_cuadratic <- lm( y~ x1*x2+ I(x1^2) + I(x2^2), data =mydata2)
summary(fit_cuadratic)
anova(fit_cuadratic)
library(qpcR)
PRESS(fit_cuadratic) #Calcula prediction R2
residuals(fit_cuadratic)
layout(matrix(c(1:4),nrow=2, ncol=2, byrow=T))
plot(fit_cuadratic)
library(alr3)
pureErrorAnova(fit_cuadratic) # Lack of fit señala un ajuste muy bueno del modelo
library (rsm)
df <- fit_cuadratic$model
df <- with(df , aggregate(y, list(Tiempo=x1, Temperatura=x2), mean))
CR1 <- coded.data(df, x1 ~ Tiempo, x2 ~ Temperatura)
fit2.rsm = rsm (x ~  SO(x1, x2), data = CR1) #Ajuste de segundo orden (SO)
summary(fit2.rsm)
CR1.rsmi <- update(fit2.rsm, . ~ . + TWI(x1, x2))
layout(matrix(c(1,2),nrow=1, ncol=2, byrow=T))
contour (CR1.rsmi, ~ (x1+x2+ x1*x2), col="black", xlabs = c("Tiempo", "Temperatura"))
persp (CR1.rsmi, ~ (x1+x2 + x1*x2), contours="col", col=rainbow(40),
xlabs = c("Tiempo", "Temperatura"), zlab = "Rendimiento")
B <- coefficients(fit_cuadratic)
1+1
misdatos=list(Nombre="Alejandra Restrepo",
Edad= 23,
Mujer= TRUE)
misdatos
misdatos[[1]]
misdatos[[2]]
misdatos[[3]]
misdatos$telefono =3006650948
misdatos
misdatos$hijos= TRUE
misdatos
misdatos$hijos= NA
misdatos
misdatos$hijos= Null
misdatos$hijos= NULL
misdatos
numero=c(1:20)
numero
genero=c(T,F,T,F)
genero
numero[1]
numero[5]
numero=numero[-4]
numero
dias=c('L','M','M','J','V','S','D')
dias=c('L','M','M','J','V','S','D')
unique(dias)
names=c("Qing", "Françoise", "Raúl", "Bjork")
ages=c(32,33,28,30)
country=c("China", "Senegal", "Spain", "Norway")
education=c("Bach", "Bach", "Master", "PhD")
#DF es una composición de columnas en formato de vector:
DF_vectors=data.frame(names,ages,country,education)
DF_vectors
#descripcion del data frame
str(DF_vector)
names=c("Qing", "Françoise", "Raúl", "Bjork")
ages=c(32,33,28,30)
country=c("China", "Senegal", "Spain", "Norway")
education=c("Bach", "Bach", "Master", "PhD")
#DF es una composición de columnas en formato de vector:
DF_vectors=data.frame(names,ages,country,education)
DF_vectors
#descripcion del data frame
str(DF_vector)
#descripcion del data frame
str(DF_vectors)
# cuantas filas y columnas tienes:
dim(students)
#descripcion del data frame
str(DF_vectors)
# cuantas filas y columnas tienes:
dim(DF_vectors)
#Cuantas filas
nrow(DF_vectors)  # we have ncol() too!
#Cuantas columnas
length(DF_vectors)
value=-100
#condicion
if (value >= 0){
# si es Verdadero
rootValue=sqrt(value)
print (rootValue)
} else {
# si es Falso
print('Lo lamento, no calculo raíces cuadradas de números negativos')
}
value=5
#condicion
if (value >= 0){
# si es Verdadero
rootValue=sqrt(value)
print (rootValue)
} else {
# si es Falso
print('Lo lamento, no calculo raíces cuadradas de números negativos')
}
values=c(9,25,100)
for (value in values){ # mientras hayan valores en 'values'
print(sqrt(value))
}
# Cargar archivo ----
# NO OLVIDAR set working directory
filename="colombia.csv"
colb=read.csv(filename, stringsAsFactors = FALSE)
# que variables y tipo
str(colb)
# Exploracion Univariada --------------------------------------------------
## estadisticos
# nos interesa IDH, y poblacion cabecera y poblacion resto
# no se puede secar tabla de frecuencia,
# solo estadisticos:
summary(colb)
## graficos
# el plot de cada uno seria el histograma:
hist(colb$IDH)
hist(colb$PoblaciÃ³n.Cabecera)
hist(colb$PoblaciÃ³n.Resto)
# dado el sesgo de las pobaciones,
# podriamos transformarla para que se acerque a la
# normalidad
colb$cabeLog=log(colb$PoblaciÃ³n.Cabecera)
colb$restoLog=log(colb$PoblaciÃ³n.Resto)
hist(colb$cabeLog)
hist(colb$restoLog)
# Exploracion Bivariada ---------------------------------------------------
# En este trabajo estamos interesados en el impacto de
# la poblacion en el el IDH, veamos IDH con cada uno:
explanans=names(colb)[c(7:8)] # usando las logs
corrDem=cor(colb$IDH,colb[,explanans],
use = "na.or.complete")
corrDem
# y la correlaciÃ³n entre las variables independientes:
corrTableX=round(cor(colb[,explanans],
use = "na.or.complete"),2)
corrTableX_copy=corrTableX
corrTableX[upper.tri(corrTableX)]<-""
#ver:
corrTableX
# visualmente:
plot(colb[,explanans])
# Modelos de RegresiÃ³n ----------------------------------------------------
# Veamos los modelos propuestos.
# Primero sin poblacion resto, luego con esa:
LinRegA = lm(IDH ~ ., data = colb[,c(1,7)])
LinRegB = lm(IDH ~ ., data = colb[,c(1,7:8)])
#resultados
summary(LinRegA)
summary(LinRegB)
# ExploraciÃ³n Espacial ----------------------------------------------------
#Calculemos conglomerados de regiones,
#usando toda la informaciÃ³n de las tres variables.
# usaremos la tecnica de k-means propuesta por MacQueen.
library(rgdal)
folder='COL_maps'
file='COL_adm1.shp'
mapaFile=file.path(folder,file)
mapCol <- rgdal::readOGR(mapaFile,stringsAsFactors=F)
# lo tenemos:
plot(mapCol)
# veamos que variables hay:
head(mapCol@data)
# con esto hagamos el merge:
sub_colb=colb[,c(1:2,7:8)]
mapCol_idh=merge(mapCol,sub_colb, by.x='NAME_1', by.y='Departamento',all.x=F)
# cuantas regiones me quedaron luego del merge?
nrow(mapCol_idh)  # todas!!...
# preparacion para clusterizar:
# que tengo?:
names(mapCol_idh)
# nombre de la variables que usarÃ©:
dimensions=c("NAME_1","IDH","cabeLog","restoLog")
# creo un nuevo data frame con esas:
dataCluster=mapCol_idh@data[,c(dimensions)]
# como la data es numerica la normalizo (menos la column 1):
dataCluster[,-1]=scale(dataCluster[,-1])
## APLICANDO TECNICA KMEANS
# calculo 3 clusters
resultado=kmeans(dataCluster[,-1],3)
#creo data frame con los clusters:
clusters=as.data.frame(resultado$cluster)
# aÃ±ado columna con nombre de regiones
clusters$NAME_1=dataCluster$NAME_1
names(clusters)=c('cluster','NAME_1')
#hago el merge hacia el mapa:
mapCol_idh=merge(mapCol_idh,clusters, by='NAME_1',all.x=F)
# lo tengo?
names(mapCol_idh)
## a pintar:
library(RColorBrewer)
library(classInt)
#variable a colorear
varToPLot=mapCol_idh$cluster
# decidir color:
unique(varToPLot)
aggregate(mapCol_idh@data[,c(10,11,12)],
by=list(mapCol_idh@data$cluster),FUN=mean)
#preparo colores
numberOfClasses = length(unique(varToPLot))
colorForScale='Set2'
paleta = brewer.pal(numberOfClasses, colorForScale)
# grafico mapa basico
plot(mapCol,col='grey',border=0)
# grafico mapa cluster
plot(mapCol_idh, col = paleta[varToPLot],border=F,add=T)
legend('left', legend = c("LOW","UP","MEDIUM"),
fill = paleta,
cex = 0.6,
bty = "n",
title="conglomerado")
filename="colombia.csv"
colb=read.csv(filename, stringsAsFactors = FALSE)
install.packages("reporttools")
install.packages("stargazer")
mydata = read.table("colombia.csv")
colb=(read_csv("C:/Users/ma.restrepot/Dropbox/MAESTRIA 201819/ProyectoFinal/ProyectoFinal/colombia.csv", stringsAsFactors = FALSE)
# que variables y tipo
str(colb)
# Exploracion Univariada --------------------------------------------------
## estadisticos
# nos interesa IDH, y poblacion cabecera y poblacion resto
# no se puede secar tabla de frecuencia,
# solo estadisticos:
summary(colb)
## graficos
# el plot de cada uno seria el histograma:
hist(colb$IDH)
hist(colb$PoblaciÃ³n.Cabecera)
hist(colb$PoblaciÃ³n.Resto)
# dado el sesgo de las pobaciones,
# podriamos transformarla para que se acerque a la
# normalidad
colb$cabeLog=log(colb$PoblaciÃ³n.Cabecera)
colb$restoLog=log(colb$PoblaciÃ³n.Resto)
hist(colb$cabeLog)
hist(colb$restoLog)
# Exploracion Bivariada ---------------------------------------------------
# En este trabajo estamos interesados en el impacto de
# la poblacion en el el IDH, veamos IDH con cada uno:
explanans=names(colb)[c(7:8)] # usando las logs
corrDem=cor(colb$IDH,colb[,explanans],
use = "na.or.complete")
corrDem
# y la correlaciÃ³n entre las variables independientes:
corrTableX=round(cor(colb[,explanans],
use = "na.or.complete"),2)
corrTableX_copy=corrTableX
corrTableX[upper.tri(corrTableX)]<-""
#ver:
corrTableX
# visualmente:
plot(colb[,explanans])
# Modelos de RegresiÃ³n ----------------------------------------------------
# Veamos los modelos propuestos.
# Primero sin poblacion resto, luego con esa:
LinRegA = lm(IDH ~ ., data = colb[,c(1,7)])
LinRegB = lm(IDH ~ ., data = colb[,c(1,7:8)])
#resultados
summary(LinRegA)
summary(LinRegB)
# ExploraciÃ³n Espacial ----------------------------------------------------
#Calculemos conglomerados de regiones,
#usando toda la informaciÃ³n de las tres variables.
# usaremos la tecnica de k-means propuesta por MacQueen.
library(rgdal)
folder='COL_maps'
file='COL_adm1.shp'
mapaFile=file.path(folder,file)
mapCol <- rgdal::readOGR(mapaFile,stringsAsFactors=F)
# lo tenemos:
plot(mapCol)
# veamos que variables hay:
head(mapCol@data)
# con esto hagamos el merge:
sub_colb=colb[,c(1:2,7:8)]
mapCol_idh=merge(mapCol,sub_colb, by.x='NAME_1', by.y='Departamento',all.x=F)
# cuantas regiones me quedaron luego del merge?
nrow(mapCol_idh)  # todas!!...
# preparacion para clusterizar:
# que tengo?:
names(mapCol_idh)
# nombre de la variables que usarÃ©:
dimensions=c("NAME_1","IDH","cabeLog","restoLog")
# creo un nuevo data frame con esas:
dataCluster=mapCol_idh@data[,c(dimensions)]
# como la data es numerica la normalizo (menos la column 1):
dataCluster[,-1]=scale(dataCluster[,-1])
## APLICANDO TECNICA KMEANS
# calculo 3 clusters
resultado=kmeans(dataCluster[,-1],3)
#creo data frame con los clusters:
clusters=as.data.frame(resultado$cluster)
# aÃ±ado columna con nombre de regiones
clusters$NAME_1=dataCluster$NAME_1
names(clusters)=c('cluster','NAME_1')
#hago el merge hacia el mapa:
mapCol_idh=merge(mapCol_idh,clusters, by='NAME_1',all.x=F)
# lo tengo?
names(mapCol_idh)
## a pintar:
library(RColorBrewer)
library(classInt)
#variable a colorear
varToPLot=mapCol_idh$cluster
# decidir color:
unique(varToPLot)
aggregate(mapCol_idh@data[,c(10,11,12)],
by=list(mapCol_idh@data$cluster),FUN=mean)
#preparo colores
numberOfClasses = length(unique(varToPLot))
colorForScale='Set2'
paleta = brewer.pal(numberOfClasses, colorForScale)
# grafico mapa basico
plot(mapCol,col='grey',border=0)
# grafico mapa cluster
plot(mapCol_idh, col = paleta[varToPLot],border=F,add=T)
legend('left', legend = c("LOW","UP","MEDIUM"),
fill = paleta,
cex = 0.6,
bty = "n",
title="conglomerado")
mydata = read.table("read_csv("C:/Users/ma.restrepot/Dropbox/MAESTRIA 201819/ProyectoFinal/ProyectoFinal/colombia.csv"")
mydata = read.table("C:/Users/ma.restrepot/Dropbox/MAESTRIA 201819/ProyectoFinal/ProyectoFinal/colombia.csv")
mydata = read.table("C:/Users/ma.restrepot/Dropbox/MAESTRIA 201819/ProyectoFinal/ProyectoFinal/colombia.csv", header=TRUE)
filename="colombia.csv"
colb=read.csv(filename, stringsAsFactors = FALSE)
filename="colombia.csv"
colb=read.csv(filename, stringsAsFactors = FALSE)
setwd("C:/Users/ma.restrepot/Dropbox/MAESTRIA 201819/ProyectoFinal/ProyectoFinal")
filename="colombia.csv"
colb=read.csv(filename, stringsAsFactors = FALSE)
colb
setwd("~/Repositorios/TutorialSimple")
install.packages("corrplot")
install.packages("rgdal")
install.packages("classInt")
setwd("C:/Users/ma.restrepot/Dropbox/MAESTRIA 201819/ProyectoFinal/ProyectoFinal")
filename="colombia.csv"
dataidx=read.csv(filename, stringsAsFactors = FALSE)
dataidx
filename="colombia.csv"
colb=read.csv(filename, stringsAsFactors = FALSE)
filename="colombia.csv"
colb=read.csv(filename, stringsAsFactors = FALSE)
str(colb)
summary(colb)
head(colb)
colb<-data.frame(colb)
head(colb)
View(colb)
View(colb)
filename="colombia.csv"
colb=read.csv(filename, stringsAsFactors = FALSE)
colb<-data.frame(colb)
nrow(colb)
setwd("C:/Users/ma.restrepot/Dropbox/MAESTRIA 201819/Tutorial_2/Tutorial_2")
setwd("C:/Users/ma.restrepot/Dropbox/MAESTRIA 201819/ProyectoFinal/ProyectoFinal")
summary(colb)
summary(colb)
setwd("C:/Users/ma.restrepot/Dropbox/MAESTRIA 201819/Tutorial_2/Tutorial_2")
stargazer(colb)
install.packages("stargazer")
stargazer(colb)
library(xtable)
tabla=as.matrix(summary(colb))
xtable(tabla,caption="Resumen",label="F3")
setwd("C:/Users/ma.restrepot/Dropbox/MAESTRIA 201819/ProyectoFinal/ProyectoFinal")
library(stargazer)
vars1 <- colb[, c(2:5)]
vars1
stargazer(vars1,title = "Medidas estadísticas", label = "stats",summary.stat = c("n", "median"))
str(colb)
hist(colb$IDH)
hist(colb$PoblaciÃ³n.Cabecera)
hist(colb$PoblaciÃ³n.Resto)
setwd("~/Repositorios/ProyectoFinalHerramientas")
filename="colombia.csv"
colb=read.csv(filename, stringsAsFactors = FALSE)
colb<-data.frame(colb)
colb$Poblacion.Cabecera<.lapply(colb$Poblacion.Cabecera, as.numeric)
colb
hist(colb$Poblacion.Cabecera, col= "red" ,main="Histograma población cabecera ",ylab="Frecuencia")
filename="colombia.csv"
colb=read.csv(filename, stringsAsFactors = FALSE)
colb<-data.frame(colb)
filename="colombia.csv"
colb=read.csv(filename, stringsAsFactors = FALSE)
hist(colb$Poblacion.Cabecera)
hist(colb$IDH)
hist(colb$PoblaciÃ³n.Cabecera)
hist(colb$PoblaciÃ³n.Resto)
hist(colb$Poblacion.Cabecera)
hist(colb$Poblacion.Resto)
summary(colb)
as.numeric(colb$Poblacion.Cabecera)
colb$Poblacion.Cabecera*1.0)
colb$cabeLog=log(colb$Poblacion.Cabecera)
colb$restoLog=log(colb$Poblacion.Resto)
hist(colb$cabeLog)
hist(colb$restoLog)
colb$cabeLog=log(colb$Poblacion.Cabecera)
colb$restoLog=log(colb$Poblacion.Resto)
hist(colb$cabeLog)
hist(colb$restoLog)
setwd("~/Repositorios/ProyectoFinalHerramientas")
explanans=names(colb)[c(7:8)] # usando las logs
corrDem=cor(colb$IDH,colb[,explanans],
use = "na.or.complete")
corrDem
explanans=names(colb)[c(7:8)] # usando las logs
corrDem=cor(colb$IDH,colb[,explanans],
use = "na.or.complete")
corrDem
colb$cabeLog=log(colb$Poblacion.Cabecera)
colb$restoLog=log(colb$Poblacion.Resto)
hist(colb$cabeLog)
explanans=names(colb)[c(7:8)] # usando las logs
corrDem=cor(colb$IDH,colb[,explanans],
use = "na.or.complete")
corrDem
filename="prueba.csv"
colb=read.csv(filename, stringsAsFactors = FALSE)
colb<-data.frame(colb)
filename="colombia.csv"
colb=read.csv(filename, stringsAsFactors = FALSE)
colb<-data.frame(colb)
View(colb)
nuevo= colb$Poblacion.Cabecera*1
nuevo
colb$cabecera= colb$Poblacion.Cabecera*1
hist(colb$cabecera)#, col= "red" ,main="Histograma población cabecera ",ylab="Frecuencia")
setwd("~/Repositorios/ProyectoFinalHerramientas")
filename="colombia.csv"
colb=read.csv(filename, stringsAsFactors = FALSE)
colb<-data.frame(colb)
colb$cabecera= colb$Poblacion.Cabecera*1
colb$cabecera= colb$Poblacion.Cabecera*1
colb$resto=colb$Poblacion.Resto*1
par(mfrow=c(2,2))
colb$cabeLog=log(colb$cabecera)
colb$restoLog=log(colb$resto)
hist(colb$cabeLog, col= "royalblue" ,main="Histograma cabecera normalizado ",ylab="Frecuencia")
explanans=names(colb)[c(7:8)] # usando las logs
corrDem=cor(colb$IDH,colb$cabeLog, colb$restoLog,
use = "na.or.complete")
corrDem
View(colb)
View(colb)
explanans=names(colb)[c(8:9)] # usando las logs
explanans
explanans=names(colb)[c(9:10)] # usando las logs
explanans
corrDem=cor(colb$IDH,colb[,explanans],
use = "na.or.complete")
corrDem
explanans=names(colb)[c(9:10)] # usando las logs
corrDem=cor(colb$IDH,colb[,explanans],
use = "na.or.complete")
corrDem
explanans=names(colb)[c(9:10)]
explanans
corrTableX=round(cor(colb[,explanans],
use = "na.or.complete"),2)
corrTableX_copy=corrTableX
corrTableX[upper.tri(corrTableX)]<-""
corrTableX
corrTableX=round(cor(colb[explanans],
use = "na.or.complete"),2)
LinRegA = lm(Democracy ~ ., data = colb[,c(9:10)])
LinRegA = lm(IDH ~ ., data = colb[,c(9:10)])
COLB$total=colb$Poblacion.Total*1
ColB$total=colb$Poblacion.Total*1
colB$total=colb$Poblacion.Total*1
colb$total=colb$Poblacion.Total*1
LinRegA = lm(IDH ~ ., data = colb[,c(9:10)])
LinRegA = lm(colb$IDH ~ colb$cabeLog, colb$restoLog)
colb$
@
<<echo=F,results=tex>>=
library(stargazer)
colb$Poblacion.Cabecera=NULL
colb$Poblacion.Resto=NULL
colb$Poblacion.Total=NULL
colb$totalLog=log(colb$total)
LinRegA = lm(IDH ~ ., data = colb[1,6])
LinRegA = lm(IDH ~ ., data = colb[1:6])
LinRegA
summary(LinRegA)
LinRegA = lm(IDH ~ cabeLog, data = colb)
summary(LinRegA)
LinRegA = lm(IDH ~ cabeLog, data = colb)
LinRegB = lm(IDH ~ restoLog, data = colb)
LinRegB = lm(IDH ~ totalLog, data = colb)
summary(LinRegA)
summary(LinRegB)
View(colb)
View(colb)
hist(colb$resto, col= "royalblue" ,main="Histograma población resto ",ylab="Frecuencia")
