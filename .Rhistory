# podriamos transformarla para que se acerque a la
# normalidad
colb$cabeLog=log(colb$Poblacion.Cabecera)
colb$restoLog=log(colb$Poblacion.Resto)
# Exploracion Bivariada --------------------------------------------------
# En este trabajo estamos interesados en el impacto de
# la poblacion en el el IDH, veamos IDH con cada uno:
explanans=names(colb)[c(7:8)] # usando las logs
corrDem=cor(colb$IDH,colb[,explanans],
use = "na.or.complete")
corrDem
# y la correlación entre las variables independientes:
corrTableX=round(cor(colb[,explanans],
use = "na.or.complete"),2)
corrTableX_copy=corrTableX
corrTableX[upper.tri(corrTableX)]<-""
#ver:
corrTableX
# Chunk 3: getMap
library(rgdal)
folder='COL_maps'
file='COL_adm1.shp'
mapaFile=file.path(folder,file)
mapCol <- rgdal::readOGR(mapaFile,stringsAsFactors=F)
# lo tenemos:
plot(mapCol)
# veamos que variables hay:
head(mapCol@data)
# Chunk 5: mergeMap
sub_colb=colb[,c(1,6,7,8)]
mapCol_idh=merge(mapCol,sub_colb, by.x='NAME_1', by.y='DepartamentoNorm',all.x=F)
nrow(mapCol_idh)
plot(mapCol)
head(mapCol@data)
sub_colb=colb[,c(1,6,7,8)]
mapCol_idh=merge(mapCol,sub_colb, by.x='ID_1', by.y='DepartamentoNorm',all.x=F)
nrow(mapCol_idh)
View(sub_colb)
sub_colb=colb[,c(1,6,7,8)]
sub_colb=sub_colb(order(sub_colb$DepartamentoNorm))
sub_colb=colb[,c(1,6,7,8)]
orden=sub_colb(order(sub_colb$DepartamentoNorm))
sub_colb=colb[,c(1,6,7,8)]
orden=sub_colb(order(sub_colb$DepartamentoNorm))
View(sub_colb)
sub_colb=colb[,c(1,6,7,8)]
sub_colb=sub_colb[order(sub_colb$DepartamentoNorm)]
View(sub_colb)
sub_colb=colb[,c(1,6,7,8)]
sub_colb=colb[,c(1,6,7,8)]
sub_colb=sub_colb[order(sub_colb$DepartamentoNorm),]
View(sub_colb)
setwd("~/REPOSITORIOS/ProyectoFinalHerramientas")
# Chunk 1: getData
# carga de datos
filename="colombia.csv"
colb=read.csv(filename, stringsAsFactors = FALSE)
colb$Poblacion.Cabecera= colb$Poblacion.Cabecera*1
colb$Poblacion.Resto=colb$Poblacion.Resto*1
str(colb)
# Chunk 2: corrTableX
## estadisticos
# nos interesa IDH, y poblacion cabecera y poblacion resto
# no se puede sacar tabla de frecuencia,
# solo estadisticos:
summary(colb)
# dado el sesgo de las pobaciones,
# podriamos transformarla para que se acerque a la
# normalidad
colb$cabeLog=log(colb$Poblacion.Cabecera)
colb$restoLog=log(colb$Poblacion.Resto)
# Exploracion Bivariada --------------------------------------------------
# En este trabajo estamos interesados en el impacto de
# la poblacion en el el IDH, veamos IDH con cada uno:
explanans=names(colb)[c(7:8)] # usando las logs
corrDem=cor(colb$IDH,colb[,explanans],
use = "na.or.complete")
corrDem
# y la correlación entre las variables independientes:
corrTableX=round(cor(colb[,explanans],
use = "na.or.complete"),2)
corrTableX_copy=corrTableX
corrTableX[upper.tri(corrTableX)]<-""
#ver:
corrTableX
# Chunk 3: getMap
library(rgdal)
folder='COL_maps'
file='COL_adm1.shp'
mapaFile=file.path(folder,file)
mapCol <- rgdal::readOGR(mapaFile,stringsAsFactors=F)
# lo tenemos:
plot(mapCol)
# veamos que variables hay:
head(mapCol@data)
# Chunk 5: mergeMap
#primero ordenas la lista en orden alfabetico
sub_colb=colb[,c(1,6,7,8)]
sub_colb=sub_colb[order(sub_colb$DepartamentoNorm),]
#luego agrego una columna ID para identificarse en vez de nombres
mapCol_idh=merge(mapCol,sub_colb, by.x='ID_1', by.y='DepartamentoNorm',all.x=F)
nrow(mapCol_idh)
# Chunk 7: clust
names(mapCol_idh)
# nombre de la variables que usaré:
dimensions=c("NAME_1","IDH","cabeLog","restoLog")
# creo un nuevo data frame con esas:
dataCluster=mapCol_idh@data[,c(dimensions)]
# como la data es numerica la normalizo (menos la column 1):
dataCluster[,-1]=scale(dataCluster[,-1])
## APLICANDO TECNICA KMEANS
# calculo 3 clusters
resultado=kmeans(dataCluster[,-1],3)
#creo data frame con los clusters:
clusters=as.data.frame(resultado$cluster)
# añado columna con nombre de regiones
clusters$NAME_1=dataCluster$NAME_1
names(clusters)=c('cluster','NAME_1')
#hago el merge hacia el mapa:
mapCol_idh=merge(mapCol_idh,clusters, by='NAME_1',all.x=F)
# lo tengo?
names(mapCol_idh)
# Chunk 8: plotMap0
library(RColorBrewer)
library(classInt)
#variable a colorear
varToPLot=mapCol_idh$cluster
# decidir color:
unique(varToPLot)
aggregate(mapCol_idh@data[,c(10,11,12)],
by=list(mapCol_idh@data$cluster),FUN=mean)
#preparo colores
numberOfClasses = length(unique(varToPLot))
colorForScale='Blues'
paleta = brewer.pal(numberOfClasses,colorForScale)
# grafico mapa basico
plot(mapCol,col='grey',border=0)
# grafico mapa cluster
plot(mapCol_idh, col = paleta[varToPLot],border=F,add=T)
legend('left', legend = c("LOW","UP","MEDIUM"),
fill = paleta,
cex = 0.6,
bty = "n",
title="conglomerado")
# Chunk 1: getData
# carga de datos
filename="colombia.csv"
colb=read.csv(filename, stringsAsFactors = FALSE)
colb$Poblacion.Cabecera= colb$Poblacion.Cabecera*1
colb$Poblacion.Resto=colb$Poblacion.Resto*1
str(colb)
# Chunk 2: corrTableX
## estadisticos
# nos interesa IDH, y poblacion cabecera y poblacion resto
# no se puede sacar tabla de frecuencia,
# solo estadisticos:
summary(colb)
# dado el sesgo de las pobaciones,
# podriamos transformarla para que se acerque a la
# normalidad
colb$cabeLog=log(colb$Poblacion.Cabecera)
colb$restoLog=log(colb$Poblacion.Resto)
# Exploracion Bivariada --------------------------------------------------
# En este trabajo estamos interesados en el impacto de
# la poblacion en el el IDH, veamos IDH con cada uno:
explanans=names(colb)[c(7:8)] # usando las logs
corrDem=cor(colb$IDH,colb[,explanans],
use = "na.or.complete")
corrDem
# y la correlación entre las variables independientes:
corrTableX=round(cor(colb[,explanans],
use = "na.or.complete"),2)
corrTableX_copy=corrTableX
corrTableX[upper.tri(corrTableX)]<-""
#ver:
corrTableX
# Chunk 3: getMap
library(rgdal)
folder='COL_maps'
file='COL_adm1.shp'
mapaFile=file.path(folder,file)
mapCol <- rgdal::readOGR(mapaFile,stringsAsFactors=F)
# lo tenemos:
plot(mapCol)
# veamos que variables hay:
head(mapCol@data)
# Chunk 5: mergeMap
#primero ordenas la lista en orden alfabetico
sub_colb=colb[,c(1,6,7,8)]
#sub_colb=sub_colb[order(sub_colb$DepartamentoNorm),]
#luego agrego una columna ID para identificarse en vez de nombres
mapCol_idh=merge(mapCol,sub_colb, by.x='NAME_1', by.y='DepartamentoNorm',all.x=F)
nrow(mapCol_idh)
# Chunk 7: clust
names(mapCol_idh)
# nombre de la variables que usaré:
dimensions=c("NAME_1","IDH","cabeLog","restoLog")
# creo un nuevo data frame con esas:
dataCluster=mapCol_idh@data[,c(dimensions)]
# como la data es numerica la normalizo (menos la column 1):
dataCluster[,-1]=scale(dataCluster[,-1])
## APLICANDO TECNICA KMEANS
# calculo 3 clusters
resultado=kmeans(dataCluster[,-1],3)
#creo data frame con los clusters:
clusters=as.data.frame(resultado$cluster)
# añado columna con nombre de regiones
clusters$NAME_1=dataCluster$NAME_1
names(clusters)=c('cluster','NAME_1')
#hago el merge hacia el mapa:
mapCol_idh=merge(mapCol_idh,clusters, by='NAME_1',all.x=F)
# lo tengo?
names(mapCol_idh)
# Chunk 8: plotMap0
library(RColorBrewer)
library(classInt)
#variable a colorear
varToPLot=mapCol_idh$cluster
# decidir color:
unique(varToPLot)
aggregate(mapCol_idh@data[,c(10,11,12)],
by=list(mapCol_idh@data$cluster),FUN=mean)
#preparo colores
numberOfClasses = length(unique(varToPLot))
colorForScale='Blues'
paleta = brewer.pal(numberOfClasses,colorForScale)
# grafico mapa basico
plot(mapCol,col='grey',border=0)
# grafico mapa cluster
plot(mapCol_idh, col = paleta[varToPLot],border=F,add=T)
legend('left', legend = c("LOW","UP","MEDIUM"),
fill = paleta,
cex = 0.6,
bty = "n",
title="conglomerado")
# Chunk 1: getData
# carga de datos
filename="colombia.csv"
colb=read.csv(filename, stringsAsFactors = FALSE)
colb$Poblacion.Cabecera= colb$Poblacion.Cabecera*1
colb$Poblacion.Resto=colb$Poblacion.Resto*1
str(colb)
# Chunk 2: corrTableX
## estadisticos
# nos interesa IDH, y poblacion cabecera y poblacion resto
# no se puede sacar tabla de frecuencia,
# solo estadisticos:
summary(colb)
# dado el sesgo de las pobaciones,
# podriamos transformarla para que se acerque a la
# normalidad
colb$cabeLog=log(colb$Poblacion.Cabecera)
colb$restoLog=log(colb$Poblacion.Resto)
# Exploracion Bivariada --------------------------------------------------
# En este trabajo estamos interesados en el impacto de
# la poblacion en el el IDH, veamos IDH con cada uno:
explanans=names(colb)[c(7:8)] # usando las logs
corrDem=cor(colb$IDH,colb[,explanans],
use = "na.or.complete")
corrDem
# y la correlación entre las variables independientes:
corrTableX=round(cor(colb[,explanans],
use = "na.or.complete"),2)
corrTableX_copy=corrTableX
corrTableX[upper.tri(corrTableX)]<-""
#ver:
corrTableX
# Chunk 3: getMap
library(rgdal)
folder='COL_maps'
file='COL_adm1.shp'
mapaFile=file.path(folder,file)
mapCol <- rgdal::readOGR(mapaFile,stringsAsFactors=F)
# lo tenemos:
plot(mapCol)
# veamos que variables hay:
head(mapCol@data)
# Chunk 5: mergeMap
#primero ordenas la lista en orden alfabetico
sub_colb=colb[,c(1,6,7,8)]
sub_colb=sub_colb[order(sub_colb$DepartamentoNorm),]
#luego agrego una columna ID para identificarse en vez de nombres
mapCol_idh=merge(mapCol,sub_colb, by.x='NAME_1', by.y='DepartamentoNorm',all.x=F)
nrow(mapCol_idh)
# Chunk 7: clust
names(mapCol_idh)
# nombre de la variables que usaré:
dimensions=c("NAME_1","IDH","cabeLog","restoLog")
# creo un nuevo data frame con esas:
dataCluster=mapCol_idh@data[,c(dimensions)]
# como la data es numerica la normalizo (menos la column 1):
dataCluster[,-1]=scale(dataCluster[,-1])
## APLICANDO TECNICA KMEANS
# calculo 3 clusters
resultado=kmeans(dataCluster[,-1],3)
#creo data frame con los clusters:
clusters=as.data.frame(resultado$cluster)
# añado columna con nombre de regiones
clusters$NAME_1=dataCluster$NAME_1
names(clusters)=c('cluster','NAME_1')
#hago el merge hacia el mapa:
mapCol_idh=merge(mapCol_idh,clusters, by='NAME_1',all.x=F)
# lo tengo?
names(mapCol_idh)
# Chunk 8: plotMap0
library(RColorBrewer)
library(classInt)
#variable a colorear
varToPLot=mapCol_idh$cluster
# decidir color:
unique(varToPLot)
aggregate(mapCol_idh@data[,c(10,11,12)],
by=list(mapCol_idh@data$cluster),FUN=mean)
#preparo colores
numberOfClasses = length(unique(varToPLot))
colorForScale='Blues'
paleta = brewer.pal(numberOfClasses,colorForScale)
# grafico mapa basico
plot(mapCol,col='grey',border=0)
# grafico mapa cluster
plot(mapCol_idh, col = paleta[varToPLot],border=F,add=T)
legend('left', legend = c("LOW","UP","MEDIUM"),
fill = paleta,
cex = 0.6,
bty = "n",
title="conglomerado")
setwd("~/REPOSITORIOS/ProyectoFinalHerramientas")
# Chunk 1: getData
# carga de datos
filename="colombia.csv"
colb=read.csv(filename, stringsAsFactors = FALSE)
colb$Poblacion.Cabecera= colb$Poblacion.Cabecera*1
colb$Poblacion.Resto=colb$Poblacion.Resto*1
str(colb)
# Chunk 2: corrTableX
## estadisticos
# nos interesa IDH, y poblacion cabecera y poblacion resto
# no se puede sacar tabla de frecuencia,
# solo estadisticos:
summary(colb)
# dado el sesgo de las pobaciones,
# podriamos transformarla para que se acerque a la
# normalidad
colb$cabeLog=log(colb$Poblacion.Cabecera)
colb$restoLog=log(colb$Poblacion.Resto)
# Exploracion Bivariada --------------------------------------------------
# En este trabajo estamos interesados en el impacto de
# la poblacion en el el IDH, veamos IDH con cada uno:
explanans=names(colb)[c(7:8)] # usando las logs
corrDem=cor(colb$IDH,colb[,explanans],
use = "na.or.complete")
corrDem
# y la correlación entre las variables independientes:
corrTableX=round(cor(colb[,explanans],
use = "na.or.complete"),2)
corrTableX_copy=corrTableX
corrTableX[upper.tri(corrTableX)]<-""
#ver:
corrTableX
# Chunk 3: getMap
library(rgdal)
folder='COL_maps'
file='COL_adm1.shp'
mapaFile=file.path(folder,file)
mapCol <- rgdal::readOGR(mapaFile,stringsAsFactors=F)
# lo tenemos:
plot(mapCol)
# veamos que variables hay:
head(mapCol@data)
sub_colb=colb[,c(1,6,7,8)]
sub_colb=sub_colb[order(sub_colb$DepartamentoNorm),]
nueva.col<-c(seq(1:32))
sub_colb$ID<-nueva.col
View(sub_colb)
View(mapCol)
View(sub_colb)
mapCol_idh=merge(mapCol,sub_colb, by.x='ID_1', by.y='ID',all.x=F)
nrow(mapCol_idh)
View(mapCol_idh)
nrow(mapCol)
nrow(mapCol_idh)
names(mapCol_idh)
dimensions=c("DepartamentoNorm","IDH","cabeLog","restoLog")
dataCluster=mapCol_idh@data[,c(dimensions)]
View(dataCluster)
dataCluster[,-1]=scale(dataCluster[,-1])
resultado=kmeans(dataCluster[,-1],3)
clusters=as.data.frame(resultado$cluster)
View(clusters)
clusters$NAME_1=dataCluster$NAME_1
names(clusters)=c('cluster','NAME_1')
View(dataCluster)
clusters$NAME_1=dataCluster$DepartamentoNorm
names(clusters)=c('cluster','NAME_1')
mapCol_idh=merge(mapCol_idh,clusters, by='NAME_1',all.x=F)
names(mapCol_idh)
library(RColorBrewer)
library(classInt)
#variable a colorear
varToPLot=mapCol_idh$cluster
# decidir color:
unique(varToPLot)
aggregate(mapCol_idh@data[,c(10,11,12)],
by=list(mapCol_idh@data$cluster),FUN=mean)
#preparo colores
numberOfClasses = length(unique(varToPLot))
colorForScale='Blues'
paleta = brewer.pal(numberOfClasses,colorForScale)
# grafico mapa basico
plot(mapCol,col='grey',border=0)
# grafico mapa cluster
plot(mapCol_idh, col = paleta[varToPLot],border=F,add=T)
legend('left', legend = c("LOW","UP","MEDIUM"),
fill = paleta,
cex = 0.6,
bty = "n",
title="conglomerado")
setwd("~/REPOSITORIOS/ProyectoFinalHerramientas")
# Chunk 1: getData
# carga de datos
filename="colombia.csv"
colb=read.csv(filename, stringsAsFactors = FALSE)
colb$Poblacion.Cabecera= colb$Poblacion.Cabecera*1
colb$Poblacion.Resto=colb$Poblacion.Resto*1
str(colb)
# Chunk 2: corrTableX
## estadisticos
# nos interesa IDH, y poblacion cabecera y poblacion resto
# no se puede sacar tabla de frecuencia,
# solo estadisticos:
summary(colb)
# dado el sesgo de las pobaciones,
# podriamos transformarla para que se acerque a la
# normalidad
colb$cabeLog=log(colb$Poblacion.Cabecera)
colb$restoLog=log(colb$Poblacion.Resto)
# Exploracion Bivariada --------------------------------------------------
# En este trabajo estamos interesados en el impacto de
# la poblacion en el el IDH, veamos IDH con cada uno:
explanans=names(colb)[c(7:8)] # usando las logs
corrDem=cor(colb$IDH,colb[,explanans],
use = "na.or.complete")
corrDem
# y la correlación entre las variables independientes:
corrTableX=round(cor(colb[,explanans],
use = "na.or.complete"),2)
corrTableX_copy=corrTableX
corrTableX[upper.tri(corrTableX)]<-""
#ver:
corrTableX
# Chunk 3: getMap
library(rgdal)
folder='COL_maps'
file='COL_adm1.shp'
mapaFile=file.path(folder,file)
mapCol <- rgdal::readOGR(mapaFile,stringsAsFactors=F)
# lo tenemos:
plot(mapCol)
# veamos que variables hay:
head(mapCol@data)
# Chunk 5: mergeMap
#primero ordenas la lista en orden alfabetico
sub_colb=colb[,c(1,6,7,8)]
sub_colb=sub_colb[order(sub_colb$DepartamentoNorm),]
#luego agrego una columna ID para identificarse en vez de nombres
nueva.col<-c(seq(1:32))
sub_colb$ID<-nueva.col
mapCol_idh=merge(mapCol,sub_colb, by.x='ID_1', by.y='ID',all.x=F)
nrow(mapCol_idh)
# Chunk 7: clust
names(mapCol_idh)
# nombre de la variables que usaré:
dimensions=c("DepartamentoNorm","IDH","cabeLog","restoLog")
# creo un nuevo data frame con esas:
dataCluster=mapCol_idh@data[,c(dimensions)]
# como la data es numerica la normalizo (menos la column 1):
dataCluster[,-1]=scale(dataCluster[,-1])
## APLICANDO TECNICA KMEANS
# calculo 3 clusters
resultado=kmeans(dataCluster[,-1],3)
#creo data frame con los clusters:
clusters=as.data.frame(resultado$cluster)
# añado columna con nombre de regiones
clusters$NAME_1=dataCluster$DepartamentoNorm
names(clusters)=c('cluster','NAME_1')
#hago el merge hacia el mapa:
mapCol_idh=merge(mapCol_idh,clusters, by='NAME_1',all.x=F)
# lo tengo?
names(mapCol_idh)
# Chunk 8: plotMap0
library(RColorBrewer)
library(classInt)
#variable a colorear
varToPLot=mapCol_idh$cluster
# decidir color:
unique(varToPLot)
aggregate(mapCol_idh@data[,c(10,11,12)],
by=list(mapCol_idh@data$cluster),FUN=mean)
#preparo colores
numberOfClasses = length(unique(varToPLot))
colorForScale='Blues'
paleta = brewer.pal(numberOfClasses,colorForScale)
# grafico mapa basico
plot(mapCol,col='grey',border=0)
# grafico mapa cluster
plot(mapCol_idh, col = paleta[varToPLot],border=F,add=T)
legend('left', legend = c("LOW","UP","MEDIUM"),
fill = paleta,
cex = 0.6,
bty = "n",
title="conglomerado")
View(clusters)
